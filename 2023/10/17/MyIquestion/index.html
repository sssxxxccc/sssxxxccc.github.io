<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/source/images/icons/bitbug_favicon16x16.ico?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/source/images/icons/bitbug_favicon32x32.ico?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="js 数据类型 、以及存储位置        基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。 引用数据类型：对象(Object)、数组(Array)、函数(Function)。  基本数据类型存放在栈 引用数据类型指针存放在栈里，值存放在堆">
<meta property="og:type" content="article">
<meta property="og:title" content="总结面试题">
<meta property="og:url" content="http://example.com/2023/10/17/MyIquestion/index.html">
<meta property="og:site_name" content="离葵">
<meta property="og:description" content="js 数据类型 、以及存储位置        基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。 引用数据类型：对象(Object)、数组(Array)、函数(Function)。  基本数据类型存放在栈 引用数据类型指针存放在栈里，值存放在堆">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5e17747a7ca8485ea10075f9ee458204.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/57b25859053047e0abf2aab3408439a4.png">
<meta property="article:published_time" content="2023-10-17T01:54:24.000Z">
<meta property="article:modified_time" content="2023-10-18T03:05:14.537Z">
<meta property="article:author" content="孙旭昌">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/5e17747a7ca8485ea10075f9ee458204.png"><title>总结面试题 | 离葵</title><link ref="canonical" href="http://example.com/2023/10/17/MyIquestion/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner" style="background: url(https://pic.netbian.com/uploads/allimg/231018/001158-1697559118762e.jpg) no-repeat center/cover;"><div class="header-banner-info"><div class="header-banner-info__title">离葵</div><div class="header-banner-info__subtitle">一辈子，能坚持做好一件事就很伟大了！</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">总结面试题</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-10-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-10-18</span></span></div></header><div class="post-body">
        <h2 id="js-数据类型-、以及存储位置"   >
          <a href="#js-数据类型-、以及存储位置" class="heading-link"><i class="fas fa-link"></i></a><a href="#js-数据类型-、以及存储位置" class="headerlink" title="js 数据类型 、以及存储位置"></a>js 数据类型 、以及存储位置</h2>
      <ul>
<li>基本类型：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。</li>
<li>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</li>
</ul>
<p>基本数据类型存放在栈</p>
<p>引用数据类型指针存放在栈里，值存放在堆</p>

        <h2 id="堆和栈的区别"   >
          <a href="#堆和栈的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2>
      <p>栈：内存小，栈存着基本的值以及引用的地址；栈是先进后出的顺序；内存自动分配 7<br>堆：内存大，堆存着引用的值；堆是没有顺序；程序员动态分配存储空间</p>

        <h2 id="阻止事件冒泡"   >
          <a href="#阻止事件冒泡" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2>
      <ol>
<li>在相应的函数中加上 event.stopPropagation()</li>
<li>判断 event.target 和 event.currentTarget 是否相等</li>
<li>IE 则是使用 e.cancelBubble &#x3D; true</li>
</ol>

        <h2 id="阻止默认行为"   >
          <a href="#阻止默认行为" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h2>
      <ol>
<li>e.preventDefault() : 非 IE 使用</li>
<li>e.returnValue &#x3D; false ：IE 使用</li>
</ol>

        <h2 id="事件委托"   >
          <a href="#事件委托" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2>
      <p>事件委托：将事件委托给外层元素（通常是已存在的元素），当事件触发时，由事件对象来判断事件源，执行对应的操作</p>

        <h2 id="事件冒泡"   >
          <a href="#事件冒泡" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2>
      <p>当一个元素上的事件被触发时，该事件会从该元素开始向上冒泡至父元素，直到到达文档根节点（document）。这意味着如果一个元素上的事件处理函数没有阻止事件冒泡，那么父元素上的相同事件处理函数也会被触发。</p>

        <h2 id="事件传播"   >
          <a href="#事件传播" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h2>
      <p>当一个元素上的事件被触发时，该事件会经历三个阶段：捕获阶段（Capture Phase）、目标阶段（Target Phase）和冒泡阶段（Bubbling Phase）。<br>在捕获阶段，事件从文档根节点（document）开始向下传播至目标元素；在目标阶段，事件在目标元素上被触发；在冒泡阶段，事件从目标元素开始向上冒泡至文档根节点。</p>

        <h2 id="事件捕获"   >
          <a href="#事件捕获" class="heading-link"><i class="fas fa-link"></i></a><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h2>
      <p>是事件传播的第一个阶段，在该阶段中，事件从文档根节点（document）开始向下传播至目标元素。<br>在事件捕获阶段，父元素上的事件处理函数会先于子元素上的事件处理函数执行。</p>

        <h2 id="Link-和-import-的区别"   >
          <a href="#Link-和-import-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Link-和-import-的区别" class="headerlink" title="Link 和@import 的区别"></a>Link 和@import 的区别</h2>
      <ol>
<li><p>link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS。</p>
</li>
<li><p>link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。</p>
</li>
<li><p>link 是 XHTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。</p>
</li>
<li><p>ink 支持使用 Javascript 控制 DOM 去改变样式；而@import 不支持。</p>
</li>
<li><p>link 引入的样式权重大于@import 引入的样式。</p>
</li>
</ol>

        <h2 id="闭包"   >
          <a href="#闭包" class="heading-link"><i class="fas fa-link"></i></a><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2>
      <p>作用是:通过一系方法,将函数内部的变量(局部变量)转化为全局变量</p>
<p>闭包的三大特性：</p>
<p>闭包是读取外层函数内部变量的函数<br>当内层函数调用外层函数的变量或参数时产生闭包<br>闭包满足三个条件： 1.必须是一个内嵌函数 2.内嵌函数必须引用外部嵌套函数中的变量 3.外部函数返回值必须是一个内嵌函数<br>闭包优缺点？<br>闭包优点:只在函数内的子函数中才能读取到局部变量，避免全局污染<br>闭包缺点：变量常驻内存，导致内存不能释放，造成内存泄漏<br>闭包使用场景:<br>1.setTimeout 2.回调 3.函数防抖</p>

        <h2 id="递归"   >
          <a href="#递归" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归" class="headerlink" title="递归"></a>递归</h2>
      <p>就是函数自己调用自己本身，或者在自己函数调用的下级函数中调用自己</p>

        <h4 id="递归的特点"   >
          <a href="#递归的特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归的特点" class="headerlink" title="递归的特点"></a>递归的特点</h4>
      <p>实际上，递归有两个显著的特征,终止条件和自身调用:</p>
<p>自身调用：原问题可以分解为子问题，子问题和原问题的求解方法是一致的，即都是调用自身的同一个函数。</p>
<p>终止条件：递归必须有一个终止的条件，即不能无限循环地调用本身。</p>

        <h2 id="防抖和节流-区别？"   >
          <a href="#防抖和节流-区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#防抖和节流-区别？" class="headerlink" title="防抖和节流 区别？"></a>防抖和节流 区别？</h2>
      <p>防抖节流就是使⽤定时器来实现我们的⽬的。</p>
<p>防抖(debounce)： 在事件被触发 n 秒后再执⾏回调，如果在这 n 秒内⼜被触发，则重新计时。 典型的案例就是输⼊框搜索：输⼊结束后 n 秒才进⾏搜索请求，n 秒内⼜输⼊的内容，则重新计时。</p>
<p>节流(throttle)： 规定在⼀个单位时间内，只能触发⼀次函数，如果这个单位时间内触发多次函数，只有⼀次⽣效。 典型的案例就是⿏标不断点击触发，规定在 n 秒内多次点击只⽣效⼀次。</p>
<p>区别：防抖只会在最后一次事件后执行触发函数，节流不管事件多么的频繁，都会保证在规定时间段内触发事件函数。</p>

        <h4 id="为什么要掌握防抖和节流"   >
          <a href="#为什么要掌握防抖和节流" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么要掌握防抖和节流" class="headerlink" title="为什么要掌握防抖和节流"></a>为什么要掌握防抖和节流</h4>
      <p>函数节流与函数防抖都是可以限制函数的执⾏频次，根据不同的场景来对执⾏频率进⾏限制，避免了函数触发频率过⾼导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象</p>

        <h2 id="强制转换-隐式转换"   >
          <a href="#强制转换-隐式转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#强制转换-隐式转换" class="headerlink" title="强制转换 隐式转换"></a>强制转换 隐式转换</h2>
      <ol>
<li>实例化对象是由构造函数 new 出来的<br>转换变量.charCodeAt()<br>数字<br>数字转字符串:<br>强制转换:string(num) num.toString;<br>隐式转换:(串数字字符串)sum+””<br>转换:字符串转换成数字<br>强制转换:Number(str),只能将纯数字字符串转成数字，其他字符串被转成 NaN;<br>parseInt(str),转成整数。从第一位开始，连续的数字会被转成数字，遇到字母结束转换，如果第一位是字母，结果是 NaN;<br>parseFloat(str),转小数。<br>隐式转换:(纯数字字符串转数字)-0 *1 &#x2F;1</li>
</ol>
<p>验证是否是具体数字 isNaN(num),num 不是具体数字时，结果是 true;数字和纯数字字符串是 false<br>转换小数的方法:<br>num.toFixed(小数位数),四舍五入</p>

        <h2 id="数组方法"   >
          <a href="#数组方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2>
      <p>1.shift 删除数组中的第⼀个元素<br>2.pop 删除数组中的最后⼀个元素<br>3.unshift 增加元素在数组的前⾯<br>4.push 增加元素在数组的后⾯<br>5.map 循环，并且返回新的数组<br>6.forEach 循环，遍历<br>7.filter 过滤，筛选出数组中的满⾜条件的，并且返回新的数组<br>8.concat 合并数组<br>9.find 查找出第⼀个符合条件中的数组元素<br>10.findIndex 查找出第⼀个符合条件中的数组元素，所在的索引位置<br>11.flat 将多维数组转为⼀维数组<br>12.join 将数组转为字符串<br>13.reverse 颠倒数组中的顺序<br>14.every 检测数组中元素是否都是符合条件 &#x3D;&#x3D;&#x3D; bollean<br>15.some 检测数组中元素是否有满⾜条件的元素 &#x3D;&#x3D;&#x3D; bollean<br>16.splice(start,n,添加元素) 从数组中删除、替换或插入元素，可指定起始位置和删除&#x2F;替换的数量<br>17.sort() 对数组中的元素进行排序<br>18.slice(start,end) 返回数组的一个片段，可以指定起始和结束位置<br>19.indexOf() 方法返回数组中第一次出现给定元素的下标，如果不存在则返回 -1<br>20.includes 查看数组中是否存在此元素<br>21.reduce() 将数组中的元素累积为一个值，从左到右依次执行指定的函数<br>22.lastIndexOf() 返回指定元素在数组中的最后一个索引，如果不存在则返回 -1</p>

        <h2 id="get-和-post-的区别"   >
          <a href="#get-和-post-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h2>
      <p>GET 请求通过 URL 传递参数，参数会显示在 URL 中，而 POST 请求通过请求体传递参数，参数不会显示在 URL 中，更加安全。<br>GET 请求可以被缓存，可以被收藏为书签，可以被历史记录保存，而 POST 请求不会被缓存，不会被收藏为书签，也不会被历史记录保存<br>GET 请求对参数的长度有限制，一般为 2048 个字符左右，即 URL 的总长度不能超过 2048 个字符；而 POST 请求对参数的长度没有限制。</p>

        <h2 id="说一下-call-bind-apply-区别"   >
          <a href="#说一下-call-bind-apply-区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#说一下-call-bind-apply-区别" class="headerlink" title="说一下 call,bind,apply 区别"></a>说一下 call,bind,apply 区别</h2>
      <p><code>call</code> 方法和 <code>apply</code> 方法的作用是一样的，都是改变函数内部 <code>this</code> 的指向。它们的区别在于传参的方式不同<br><code>call</code>方法是将参数依次传入，而 <code>apply</code> 方法是将参数以数组的形式传入。<br><code>bind</code> 方法则是创建一个新的函数，将原函数的执行上下文绑定到指定的对象上，并返回这个新函数。这个新函数不会立即执行，而是在调用时才执行。</p>
<p>1、相同点<br>三个都是用于改变 this 指向<br>接收的第一个参数都是 this<br>都可以利用后续参数传参<br>2、不同点<br>call 和 bind 传参相同，多个参数依次传入的<br>apply 只有两个参数，第二个参数为数组<br>call 和 apply 都是对函数进行直接调用，而 bind 方法不会立即调用函数，而是返回一个修改 this 后的函数</p>

        <h2 id="箭头函数"   >
          <a href="#箭头函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2>
      <p>箭头函数的重要特征：箭头函数中没有 this 和 arguments<br>箭头函数没有自己的 this 指向，它会捕获自己定义所处的外层执行环境，并且继承这个 this 值,<br>指向当前定义时所在的对象。箭头函数的 this 指向在被定义的时候就确定了，之后永远都不会改变。<br>即使使用 call()、apply()、bind()等方法改变 this 指向也不可以</p>

        <h2 id="普通函数与箭头函数的区别"   >
          <a href="#普通函数与箭头函数的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通函数与箭头函数的区别" class="headerlink" title="普通函数与箭头函数的区别?"></a>普通函数与箭头函数的区别?</h2>
      <ul>
<li>箭头函数没有原型对象 prototype</li>
<li>箭头函数是匿名函数不能作为构造函数不能被 new</li>
<li>箭头函数不能当作 Generator(zai ne rui de)函数，不能使用 yeild(ye er de)关键字。</li>
<li>箭头函数不绑定 arguments，取而代之用 rest 参数…解决</li>
<li>箭头函数不绑定 this，会捕获他所在上下文的 this 值，作为自己的 this 值</li>
<li>箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply()</li>
</ul>

        <h2 id="this-指向"   >
          <a href="#this-指向" class="heading-link"><i class="fas fa-link"></i></a><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2>
      <p>this 的意思是一个指针型变量，它动态指向当前函数的运行环境。</p>
<p>​ 1、普通函数：关于 this，谁调用就指向谁，没有调用者，就指向全局对象 window。<br>​ 2、箭头函数：箭头函数的 this 指向于函数作用域所用的对象，上下文关系。<br>​ 3、在全局作用域下，this 始终指向全局对象 window，无论是否是严格模式<br>​ congsole.log()完整的写法是 window.console.log(),window 可以省略，window 调用了 console.log()方法，所以此时 this 指向 window。</p>

        <h2 id="ajax-请求时，解析-json-数据？"   >
          <a href="#ajax-请求时，解析-json-数据？" class="heading-link"><i class="fas fa-link"></i></a><a href="#ajax-请求时，解析-json-数据？" class="headerlink" title="ajax 请求时，解析 json 数据？"></a>ajax 请求时，解析 json 数据？</h2>
      <p>在使用 AJAX 发送请求时，如果响应的数据是 JSON 格式的，需要将 JSON 数据解析成 JavaScript 对象或数组才能使用。</p>
<p>在 JavaScript 中，可以使用内置的 <code>JSON</code> 对象提供的 <code>parse()</code> 方法将 JSON 数据解析成 JavaScript 对象或数组。<code>JSON.parse()</code> 方法接收一个 JSON 字符串作为参数，并返回一个对应的 JavaScript 对象或数组。</p>

        <h2 id="原生-Ajax-五个基本步骤"   >
          <a href="#原生-Ajax-五个基本步骤" class="heading-link"><i class="fas fa-link"></i></a><a href="#原生-Ajax-五个基本步骤" class="headerlink" title="原生 Ajax 五个基本步骤"></a>原生 Ajax 五个基本步骤</h2>
      <p>1、创建 ajax 对象<br>var xhr &#x3D; new XMLHttpRequest();</p>
<p>2、用 ajax 对象的 open 方法设置连接服务器的参数<br>xhr.open( method,url,async);<br>method:请求类型，post 或 get<br>url：请求文件的具体地址<br>async：是否异步（true 为异步，false 为同步）</p>
<p>3、设置发送数据的头部，一般用来说明数据格式，如：<br>xhr.setRequestHeader(“Content-type”,“application&#x2F;x-www-form-urlencoded”);<br>注： multipart&#x2F;form-data（一般在发送文件时使用，以二进制形式发送）和 application&#x2F;json（发送 json 格式数据）</p>
<p>4、发送请求，xhr.send(数据)<br>方法参数中 get 方法时添 null 或不添，推荐用 post 方法</p>
<p>5、判断通讯状态或接收返回数据</p>

        <h2 id="深拷贝-浅拷贝-区别？"   >
          <a href="#深拷贝-浅拷贝-区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#深拷贝-浅拷贝-区别？" class="headerlink" title="深拷贝 浅拷贝 区别？"></a>深拷贝 浅拷贝 区别？</h2>
      <p>浅拷贝：只拷贝基本类型的数据，而符合类型的数据只复制指向其的指针，而不复制对象本身，新旧对象还是共享同一块内存</p>
<p>深拷贝：会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>
<p>浅拷贝实现方式：<br>Object.assion() 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象<br>Array.prototype.concat() 合并<br>Array.prototype.slice()输入 url 之后做了哪些事<br>扩展运算符<br>深拷贝实现方式：<br>JSON.parse(JSON.stringify())<br>递归方法<br>函数库 lodash</p>

        <h2 id="原型和原型链"   >
          <a href="#原型和原型链" class="heading-link"><i class="fas fa-link"></i></a><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2>
      <p>原型：<br>原型就是一个为对象实例定义了一些公共属性和公共方法的对象模板。</p>
<p>原型链：<br>对象之间的继承关系通过构造函数的 prototype 指向父类对象，直到指向 Object 对象为止形成的指向链条。<br>通俗讲： 原型链是原型对象创建过程的历史记录。<br>注：在 javascript 中，所有的对象都拥有一个<strong>proto</strong>属性指向该对象的原型（prototype) 。</p>

        <h2 id="高阶函数"   >
          <a href="#高阶函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2>
      <blockquote>
<p>高阶函数是指使用其它函数作为参数、或者返回一个函数作为返回值的函数</p>
</blockquote>
<p>常见的高阶函数</p>
<ul>
<li>Array.prototype.map</li>
<li>Array.prototype.filter</li>
<li>Array.prototype.forEach</li>
<li>Array.prototype.reduce</li>
</ul>

        <h2 id="同源策略"   >
          <a href="#同源策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2>
      <p>域名、协议、端口完全一致即为同源。</p>

        <h2 id="面向对象"   >
          <a href="#面向对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2>
      <p>对象，就是对问题中的事物的抽象<br>面向对象：<br>就是把现实中的事物都抽象为“对象”。每个对象是唯一的，且都可以拥有它的属性与行为。我们就可以通过调用这些对象的方法、属性去解决问题。</p>
<p>三个基本特性：<br>1、封装<br>封装(encapsulation)即信息隐蔽。它是指在确定系统的某一部分内容时，应考虑到其它部分的信息及联系都在这一部分的内部进行，外部各部分之间的信息联系应尽可能的少。 2.继承<br>继承：让某个类型的对象获得另一个类型的对象的属性和方法。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 3.多态<br>多态：对于同一个行为，不同的子类对象具有不同的表现形式。多态存在的 3 个条件：<br>（1）继承 （2）重写 （3）父类引用指向子类对象。</p>

        <h2 id="CSS3-新特性"   >
          <a href="#CSS3-新特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h2>
      <p>1.新增选择器<br>属性选择器<br>结构伪类选择器<br>伪元素选择器 2.盒子模型 border-box 3.图片变模糊（fliter） 4.计算盒子宽度 width:calc 函数 5.过渡（transition）<br>6.2D 旋转<br>位移 translate()<br>旋转 rotate()<br>缩放 scale()<br>倾斜 skew()<br>矩阵 matrix() 7.动画<br>8.3D 转换<br>rotateX()<br>rotateY()<br>rotateZ()</p>

        <h2 id="HTML5-新标签"   >
          <a href="#HTML5-新标签" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTML5-新标签" class="headerlink" title="HTML5 新标签"></a>HTML5 新标签</h2>
      <p>1.新增语义化标签 2.新增多媒体标签<br>音频<br>视频 3.新增 input 类型</p>
<p><img src="https://img-blog.csdnimg.cn/5e17747a7ca8485ea10075f9ee458204.png" style="zoom: 67%;" /> 4.新增表单属性<br><img src="https://img-blog.csdnimg.cn/57b25859053047e0abf2aab3408439a4.png" alt="https://img-blog.csdnimg.cn/57b25859053047e0abf2aab3408439a4.png" style="zoom:67%;" /></p>

        <h2 id="display-none-与-visibility-hidden-的区别是什么？"   >
          <a href="#display-none-与-visibility-hidden-的区别是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#display-none-与-visibility-hidden-的区别是什么？" class="headerlink" title="display:none 与 visibility:hidden 的区别是什么？"></a>display:none 与 visibility:hidden 的区别是什么？</h2>
      <p>display : 隐藏对应的元素但不挤占该元素原来的空间。</p>
<p>visibility: 隐藏对应的元素并且挤占该元素原来的空间。</p>

        <h2 id="Promise"   >
          <a href="#Promise" class="heading-link"><i class="fas fa-link"></i></a><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2>
      <p>Promise 是异步编程的一种解决方案：<br>从语法上讲，promise 是一个对象，从它可以获取异步操作的消息；<br>从本意上讲，它是承诺，承诺它过一段时间会给你一个结果。</p>
<p>promise 有三种状态： pending(等待态)，resolved(fulfilled)(成功态)，rejected(失败态)；状态一旦改变，就不会再变。创造 promise 实例后，它会立即执行</p>
<p>promise 是用来解决两个问题的：</p>
<p>回调地狱，代码难以维护， 常常第一个的函数的输出是第二个函数的输入这种现象<br>promise 可以支持多个并发的请求，获取并发请求中的数据<br>这个 promise 可以解决异步的问题，本身不能说 promise 是异步的</p>

        <h2 id="Promise-方法"   >
          <a href="#Promise-方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Promise-方法" class="headerlink" title="Promise 方法"></a>Promise 方法</h2>
      
        <h3 id="一、Promise-静态方法"   >
          <a href="#一、Promise-静态方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、Promise-静态方法" class="headerlink" title="一、Promise 静态方法"></a>一、Promise 静态方法</h3>
      <ul>
<li>Promise.all() 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例</li>
<li>Promise.race() 返回最快完成那一个 Promise 实例</li>
<li><code>Promise.allSettled()</code> 方法只有等到参数数组的所有 Promise 实例都发生状态变更，返回的 Promise 实例才会发生状态变更，无论是执行 resolve 回调还是 reject 回调的状态</li>
<li><code>Promise.any()</code> 方法是返回任意一个最快执行 resolve 回调的 Promise 实例</li>
<li><code>Promise.resolve()</code> 创建一个已解决的 Promise 实例</li>
<li><code>Promise.reject()</code> 创建一个带有拒绝原因的 Promise 实例</li>
</ul>

        <h3 id="二、Promise-实例方法"   >
          <a href="#二、Promise-实例方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、Promise-实例方法" class="headerlink" title="二、Promise 实例方法"></a>二、Promise 实例方法</h3>
      <ul>
<li>then(onFulfilled, onRejected)：用于处理 Promise 对象的成功状态。它接受一个回调函数作为参数，当 Promise 对象的状态变为成功时，该回调函数会被调用，并且可以接收到 Promise 对象传递的成功值作为参数。</li>
<li>catch(onRejected)：用于处理 Promise 对象的失败状态。它接受一个回调函数作为参数，当 Promise 对象的状态变为失败时，该回调函数会被调用，并且可以接收到 Promise 对象传递的错误值作为参数。</li>
<li>finally(onFinally)：用于指定无论 Promise 对象的状态如何，都会执行的回调函数。它接受一个回调函数作为参数，无论 Promise 对象的状态是成功还是失败，都会在最后执行该回调函数。</li>
</ul>

        <h3 id="三、语法糖-Async-Await"   >
          <a href="#三、语法糖-Async-Await" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、语法糖-Async-Await" class="headerlink" title="三、语法糖 Async&#x2F;Await"></a>三、语法糖 Async&#x2F;Await</h3>
      <p>在 ES8 中新增了 Promise 的语法糖 async await 来更优雅的处理异步。</p>

        <h2 id="浏览器存储，他们的区别？"   >
          <a href="#浏览器存储，他们的区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#浏览器存储，他们的区别？" class="headerlink" title="浏览器存储，他们的区别？"></a>浏览器存储，他们的区别？</h2>
      <ul>
<li>localStorage：永久保存，以键值对保存，存储空间 5M</li>
<li>sessionStorage：关闭页签&#x2F;浏览器时清空</li>
<li>cookie：随着请求发送，通过设置过期时间删除</li>
<li>session：保存在服务端</li>
</ul>

        <h2 id="什么是回调函数"   >
          <a href="#什么是回调函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是回调函数" class="headerlink" title="什么是回调函数"></a>什么是回调函数</h2>
      <p>调用本身</p>

        <h2 id="js-创建对象的方式"   >
          <a href="#js-创建对象的方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#js-创建对象的方式" class="headerlink" title="js 创建对象的方式"></a>js 创建对象的方式</h2>
      <p>利用<strong>字面量</strong>创建对象<br>利用<strong>new Object</strong>创建对象<br>利用<strong>构造函数</strong>创建对象</p>

        <h2 id="let-与-const-和-var-的区别"   >
          <a href="#let-与-const-和-var-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#let-与-const-和-var-的区别" class="headerlink" title="let 与 const 和 var 的区别"></a>let 与 const 和 var 的区别</h2>
      <p>var 有变量提升 let 和 const 没有变量提升<br>var 可以重复声明 let,const 不允许重复声明<br>var 没有块级作用域,let 和 const 有块级作用域<br>let 和 const 声明的变量具有暂时性死区</p>
<p>4、在全局作用域，用<code>var</code>声明的变量，会作为<code>window</code>的一个属性。而用<code>let</code>和<code>const</code>声明的变量或常量，并不会作为<code>window</code>的属性</p>

        <h2 id="DOM-和-BOM-的区别"   >
          <a href="#DOM-和-BOM-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#DOM-和-BOM-的区别" class="headerlink" title="DOM 和 BOM 的区别"></a>DOM 和 BOM 的区别</h2>
      <p>DOM（文档对象模型）和 BOM（浏览器对象模型）是两个不同的概念，它们分别表示浏览器中的两个不同的对象模型。</p>
<p>DOM 是一种用于访问和操作 HTML 和 XML 文档的标准对象模型。它将文档解析为一个由节点和对象组成的结构集合，开发者可以通过 DOM 提供的 API 对文档进行增删改查等操作。</p>
<p>BOM 则是浏览器提供的一组对象，用于控制浏览器窗口及其相关功能，如浏览器历史记录、浏览器窗口大小、浏览器定位等。BOM 包括了 window 对象、location 对象、navigator 对象、screen 对象等。</p>
<p>因此，DOM 和 BOM 的区别在于它们所处理的对象不同，DOM 处理的是文档对象，而 BOM 处理的是浏览器对象。</p>

        <h2 id="浏览器输入-url-之后做了哪些事"   >
          <a href="#浏览器输入-url-之后做了哪些事" class="heading-link"><i class="fas fa-link"></i></a><a href="#浏览器输入-url-之后做了哪些事" class="headerlink" title="浏览器输入 url 之后做了哪些事"></a>浏览器输入 url 之后做了哪些事</h2>
      <ol>
<li>在浏览器地址栏中输入网址。</li>
<li>浏览器通过用户在地址栏中输入的 URL 构建 HTTP 请求报文。</li>
<li>浏览器发起 DNS 解析请求，将域名转换为 IP 地址。</li>
<li>浏览器将请求报文发送给服务器。</li>
<li>服务器接收请求报文（request），并解析。</li>
<li>服务器处理用户请求，并将处理结果封装成 HTTP 响应报文（response）。</li>
<li>服务器将 HTTP 响应报文发送给浏览器。</li>
<li>浏览器接收服务器响应的 HTTP 报文，并解析。</li>
<li>浏览器解析 HTML 页面并展示，在解析 HTML 页面时遇到新的资源需要再次发起请求。</li>
<li>最终浏览器展示出了页面</li>
</ol>

        <h2 id="改变-this-指向的方式"   >
          <a href="#改变-this-指向的方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#改变-this-指向的方式" class="headerlink" title="改变 this 指向的方式"></a>改变 this 指向的方式</h2>
      <p>JavaScript 中有多种方法可以改变函数内部的 this 指向，以下是常用的几种方式：</p>
<ol>
<li><p>使用 call()或 apply()方法：这两个方法可以显式地指定函数内部的 this 指向，call()和 apply()的第一个参数都是要绑定的 this 对象，call()的后续参数是函数的参数列表，apply()的第二个参数是一个数组，包含函数的参数列表。</p>
</li>
<li><p>使用 bind()方法：bind()方法会创建一个新的函数，将原函数的 this 指向绑定到指定的对象上，返回一个新的函数。bind()方法的第一个参数是要绑定的 this 对象，后续参数是函数的参数列表。</p>
</li>
<li><p>使用箭头函数：箭头函数没有自己的 this，它的 this 指向在定义时就已经确定，指向定义时的作用域。因此，箭头函数可以用来解决 this 指向问题。</p>
</li>
</ol>
<p>需要注意的是，箭头函数不能用作构造函数，因为它没有自己的 this，也不能通过 new 关键字调用。</p>

        <h2 id="new-操作符的作用"   >
          <a href="#new-操作符的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#new-操作符的作用" class="headerlink" title="new 操作符的作用"></a>new 操作符的作用</h2>
      <p>new 操作符用于创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
<p>new 关键字会进行如下的操作：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建一个新的空对象。</span><br><span class="line">将这个新对象的__proto__属性指向构造函数的prototype属性。</span><br><span class="line">将构造函数的作用域赋给新对象（即将this指向这个新对象）。</span><br><span class="line">执行构造函数的代码，初始化新对象的属性和方法。</span><br><span class="line">返回这个新对象。</span><br></pre></td></tr></table></div></figure>


        <h2 id="三次握手和四次挥手"   >
          <a href="#三次握手和四次挥手" class="heading-link"><i class="fas fa-link"></i></a><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h2>
      <p>三次握手（Three-way Handshake）和四次挥手（Four-way Handshake）是 TCP 协议中用于建立和关闭连接的过程。</p>

        <h3 id="三次握手（建立连接）的过程如下："   >
          <a href="#三次握手（建立连接）的过程如下：" class="heading-link"><i class="fas fa-link"></i></a><a href="#三次握手（建立连接）的过程如下：" class="headerlink" title="三次握手（建立连接）的过程如下："></a>三次握手（建立连接）的过程如下：</h3>
      <ol>
<li>客户端向服务器发送一个 SYN（同步）请求报文，标志位为 SYN&#x3D;1，序列号为 x。</li>
<li>服务器收到请求后，向客户端发送一个 SYN-ACK（同步-确认）应答报文，标志位为 SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，序列号为 y。</li>
<li>客户端收到应答后，向服务器发送一个 ACK（确认）报文，标志位为 ACK&#x3D;1，确认号为 y+1。</li>
</ol>
<p>这样，客户端和服务器都确认了对方的收发能力，建立了可靠的连接。</p>

        <h3 id="四次挥手（关闭连接）的过程如下："   >
          <a href="#四次挥手（关闭连接）的过程如下：" class="heading-link"><i class="fas fa-link"></i></a><a href="#四次挥手（关闭连接）的过程如下：" class="headerlink" title="四次挥手（关闭连接）的过程如下："></a>四次挥手（关闭连接）的过程如下：</h3>
      <ol>
<li>客户端向服务器发送一个 FIN（结束）报文，标志位为 FIN&#x3D;1，序列号为 m。</li>
<li>服务器收到请求后，向客户端发送一个 ACK（确认）报文，标志位为 ACK&#x3D;1，确认号为 m+1。</li>
<li>服务器继续发送一个 FIN 报文，标志位为 FIN&#x3D;1，序列号为 n。</li>
<li>客户端收到请求后，向服务器发送一个 ACK 报文，标志位为 ACK&#x3D;1，确认号为 n+1。</li>
</ol>
<p>这样，客户端和服务器都完成了关闭连接的过程。</p>
<p>需要注意的是，三次握手和四次挥手是为了确保双方都能够可靠地建立和关闭连接。在实际应用中，可能会出现网络延迟、丢包等问题，因此这些过程是为了保证连接的可靠性和完整性。</p>

        <h2 id="H5-的-API"   >
          <a href="#H5-的-API" class="heading-link"><i class="fas fa-link"></i></a><a href="#H5-的-API" class="headerlink" title="H5 的 API"></a>H5 的 API</h2>
      <ol>
<li>Canvas API：用于在网页上绘制图形、动画和游戏等。通过 Canvas API，可以使用 JavaScript 动态地绘制图形，实现各种视觉效果。</li>
<li>Geolocation API：用于获取用户的地理位置信息。通过 Geolocation API，可以获取用户的经纬度坐标，实现基于位置的服务和功能。</li>
<li>Web Storage API：用于在浏览器中存储数据。通过 Web Storage API，可以使用 localStorage 和 sessionStorage 对象，将数据保存在浏览器中，实现本地数据的存储和读取。</li>
<li>Web Workers API：用于在后台线程中执行 JavaScript 代码，以避免阻塞主线程。通过 Web Workers API，可以创建一个独立的工作线程，执行复杂的计算或处理大量数据，不影响页面的响应性能。</li>
<li>WebSockets API：用于在 Web 应用中实现实时的双向通信。通过 WebSockets API，可以建立一个持久的连接，实现服务器和客户端之间的实时数据传输。</li>
<li>Drag and Drop API：用于实现拖放功能。通过 Drag and Drop API，可以将元素从一个位置拖到另一个位置，实现用户友好的拖放操作。</li>
<li>Audio 和 Video API：用于在网页中播放音频和视频。通过 Audio 和 Video API，可以使用 HTML5 的<code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>标签，控制音频和视频的播放、暂停、音量等。</li>
</ol>

        <h2 id="sass-语法"   >
          <a href="#sass-语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#sass-语法" class="headerlink" title="sass 语法"></a>sass 语法</h2>
      <p>Sass（Syntactically Awesome Style Sheets）是一种 CSS 预处理器，它扩展了 CSS 的功能，提供了更强大、更灵活的样式表编写方式。Sass 有两种语法：Sass（缩进语法）和 SCSS（Sassy CSS）。</p>
<ol>
<li>Sass（缩进语法）：<ul>
<li>使用缩进来表示层级关系，而不是使用花括号 <code>&#123;&#125;</code>。</li>
<li>使用冒号 <code>:</code> 分隔属性和值，而不是使用分号 <code>;</code>。</li>
<li>使用换行符来分隔不同的样式规则。</li>
<li>使用 <code>$</code> 符号来定义变量，例如 <code>$color: red;</code>。</li>
<li>使用 <code>&amp;</code> 符号来表示父元素，例如 <code>&amp;:hover &#123; ... &#125;</code>。</li>
</ul>
</li>
</ol>

        <h2 id="作用域和作用域链之间的关系"   >
          <a href="#作用域和作用域链之间的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用域和作用域链之间的关系" class="headerlink" title="作用域和作用域链之间的关系"></a>作用域和作用域链之间的关系</h2>
      <p>作用域是指代码中变量和函数的可访问性和可见性的范围。而作用域链是指在嵌套的函数中，内部函数可以访问外部函数的作用域，形成一个链式结构。</p>
<p>在 JavaScript 中，每个函数都会创建一个新的作用域。当函数被调用时，会创建一个新的作用域，并将其添加到作用域链的顶部。作用域链的顶部是当前函数的作用域，然后是外部函数的作用域，一直到全局作用域。</p>
<p>作用域链的存在使得内部函数可以访问外部函数的变量和函数，但外部函数不能访问内部函数的变量和函数。这种嵌套的作用域链关系可以形成多层级的作用域链。</p>
<p>总结来说，作用域是指变量和函数的可访问性范围，而作用域链是指在嵌套的函数中，内部函数可以访问外部函数的作用域。这种作用域链的关系使得代码可以灵活地访问和共享变量和函数。</p>

        <h2 id="Math-常用的方法"   >
          <a href="#Math-常用的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Math-常用的方法" class="headerlink" title="Math 常用的方法"></a>Math 常用的方法</h2>
      <p>Math.abs()求绝对值<br>Math.ceil&#x2F;Math.floor 向上取整，向下取整<br>Math.round()四舍五入<br>Math.sqrt()开平方<br>Math.pow(n,m)取幂<br>Math.PI<br>Math.max&#x2F;Math.min 获取最大值和最小值<br>Math.random()获取 0~1 之间的随机数(大于等于 0 小于 1)</p>

        <h2 id="ES6-新特性"   >
          <a href="#ES6-新特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h2>
      <p>let 和 const<br>symbol 是一种新的原始数据类型 Symbol 表示独一无二的值，是 javascript 语言的第七种数据类型<br>模板字符串<br>解构表达式<br>数组解构<br>对象解构<br>对象方面<br>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型都可以作为一个键或一个值。<br>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>数组的新方法<br>Array.from() 静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。<br>Array.includes() 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。<br>Array.map() 创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。<br>Array.filter() 创建给定数组一部分的浅拷贝，其包含通过所提供函数实现的测试的所有元素<br>Array.forEach() 对数组的每个元素执行一次给定的函数。<br>Array.find() 返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined<br>Array.some() 判断是否有元素符合条件<br>Array.every() 判断每个元素都符合条件<br>Array.reduce() 接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br>object 的新方法<br>Object.is() 判断两个值是否相等<br>Object.assign() 把一个对象复制到另一个对象<br>Object.keys() 返回一个由给定对象自身的可枚举的字符串键属性名组成的数组。<br>Object.values() 返回一个给定对象的自有可枚举字符串键属性值组成的数组。<br>Object.entries() 返回一个数组，包含给定对象自有的可枚举字符串键属性的键值对。<br>对象声明简写<br>(扩展扩展符…)<br>6、函数方面<br>参数默认值<br>箭头函数<br>箭头函数和普通函数最大的区别在于其内部 this 永远指向其父级对象的 this。(重点)<br>7、class（类）<br>本质：class 的本质是 function，它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法<br>提升：函数声明会提升 class 类不会提升<br>8、promise 和 proxy<br>9、模块化<br>10、运算符</p>

        <h2 id="前端性能优化的方法"   >
          <a href="#前端性能优化的方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#前端性能优化的方法" class="headerlink" title="前端性能优化的方法"></a>前端性能优化的方法</h2>
      <p>1、减少请求数量<br>2、减少资源大小<br>3、优化网络连接<br>4、优化资源加载<br>5、减少重绘回流<br>6、性能更好的 API<br>7、webpack 性能优化</p>

        <h2 id="JavaScript-垃圾回收原理？"   >
          <a href="#JavaScript-垃圾回收原理？" class="heading-link"><i class="fas fa-link"></i></a><a href="#JavaScript-垃圾回收原理？" class="headerlink" title="JavaScript 垃圾回收原理？"></a>JavaScript 垃圾回收原理？</h2>
      <p>在 javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收；<br>如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。</p>

        <h2 id="判断一个对象是否为空"   >
          <a href="#判断一个对象是否为空" class="heading-link"><i class="fas fa-link"></i></a><a href="#判断一个对象是否为空" class="headerlink" title="判断一个对象是否为空"></a>判断一个对象是否为空</h2>
      <p>1.将对象转换成字符串，再判断是否等于”{}”<br>2.for in 循环<br>3.Object.keys()方法，返回对象的属性名组成的一个数组，若长度为 0，则返回空对象(ES6 写法)<br>4.Object.getOwnPropertyNames()方法获取对象的属性名，存到数组中，如果长度为 0，则为空对象<br>5.jQuery 中的 isEmptyObject()方法，其原理是利用 for in 方式来判断(注意：使用这种方式记得引用 jQuery)</p>

        <h2 id="HTML-渲染过程"   >
          <a href="#HTML-渲染过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#HTML-渲染过程" class="headerlink" title="HTML 渲染过程"></a>HTML 渲染过程</h2>
      <ol>
<li><p>解析 HTML 文件，创建 DOM 树<br>浏览器解析 html 代码，然后创建一个 DOM 树。并行请求 css&#x2F;image&#x2F;js 在 DOM 树中，每一个 HTML 标签都有一个对应的结点，并且每一个文本也都会有一个对应的文本节点。DOM 树的根节点就是 documentELement，对应的是 html 标签。</p>
</li>
<li><p>解析 CSS，形成 CSS 对象模型<br>浏览器解析 CSS 代码，计算出最终的样式数据。构建 CSSOM 树。对 CSS 代码中非法的羽凡它会直接忽略掉。解析 CSS 的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外联样式 &lt; 内联样式 &lt; html 中的 style</p>
</li>
<li><p>将 CSS 与 DOM 合并，构建渲染树（rendering tree）<br>DOM Tree + CSSOM -&gt; 渲染树（rendering tree）。渲染树和 DOM 树有点像，但是是有区别的。DOM 树完全和 html 标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每个节点都存储有对应的 css 属性。</p>
</li>
<li><p>布局和绘制<br>一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上</p>
</li>
</ol>

        <h2 id="axios"   >
          <a href="#axios" class="heading-link"><i class="fas fa-link"></i></a><a href="#axios" class="headerlink" title="axios"></a>axios</h2>
      <p>Axios 是一个基于 Promise 的<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=HTTP%E5%AE%A2%E6%88%B7%E7%AB%AF&spm=1001.2101.3001.7020" >HTTP 客户端</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>库，用于浏览器和 Node.js 中发送异步 HTTP 请求。它提供了一种简洁且易于使用的方式来处理 HTTP 请求和响应。</p>
<p>Axios 的底层原理主要包括：基于 XMLHttpRequest 或者浏览器的 fetch API 发送请求、封装请求和响应、Promise 和异步处理、拦截器、错误处理、取消请求</p>

        <h1 id="VUE"   >
          <a href="#VUE" class="heading-link"><i class="fas fa-link"></i></a><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1>
      
        <h2 id="什么是-vuex？"   >
          <a href="#什么是-vuex？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是-vuex？" class="headerlink" title="什么是 vuex？"></a>什么是 vuex？</h2>
      <p>vuex 是状态管理仓库，可以实现对多个组件公共状态的集中式管理。它包含了 state、getters、mutations，actions，modules 五个属性。</p>
<p>state：用于存储维护组件的公共状态,</p>
<p>getters：用于对 state 中的数据进行相关处理后并返回，类似于计算属性，</p>
<p>mutations：是修改 state 的唯一途径，进行的是同步操作，</p>
<p>actions：要执行的操作，可以是同步或异步事件，</p>
<p>modules：内部可以存放多个仓库配置对象，用于对仓库进行模块划分</p>

        <h2 id="vue-js-的两个核心是什么？"   >
          <a href="#vue-js-的两个核心是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#vue-js-的两个核心是什么？" class="headerlink" title="vue.js 的两个核心是什么？"></a>vue.js 的两个核心是什么？</h2>
      <p>1、数据驱动，也叫双向数据绑定。</p>
<p>2、组件系统</p>
<p>​ 1、模板（template）：模板声明了数据和最终展现给用户的 DOM 之间的映射关系。<br>​ 2、初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状 态。 3、接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。<br>​ 4、方法（methods）：对数据的改动操作一般都在组件的方法内进行。<br>​ 5、生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新 2.0 版本 对于生命周期函数名称改动很大。<br>​ 6、私有资源（assets）：Vue.js 当中将用户自定义的指令、过滤器、组件等统称为资源。一个组 件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用等等。</p>

        <h2 id="vuex-的工作流程"   >
          <a href="#vuex-的工作流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#vuex-的工作流程" class="headerlink" title="vuex 的工作流程"></a>vuex 的工作流程</h2>
      <p>首先通过 dispatch 去提交一个 actions，在 actions 接收到这个事件后，在 actions 种进行一些异步或同步操作，根据情况分发给不同的 mutations，actions 通过 commit 触发 mutations，然后 mutations 去更新 state，在 state 更新后，就会通知 vue 进行渲染。步骤如下：</p>
<p>1.通过 dispatch 去提交一个 actions</p>
<p>2.在 actions 接收到事件后，在 actions 中执行一些同步或异步操作</p>
<p>3.根据不同的情况分发给不同的 mutations，actions 通过 commit 触发 mutations</p>
<p>4.mustations 在触发后就会去更新 state</p>
<p>5.在 state 更新完毕后，就会通知 vue 进行渲染</p>

        <h2 id="Vue-中的-computed-和-watch、methods-的区别"   >
          <a href="#Vue-中的-computed-和-watch、methods-的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Vue-中的-computed-和-watch、methods-的区别" class="headerlink" title="Vue 中的 computed 和 watch、methods 的区别"></a>Vue 中的 computed 和 watch、methods 的区别</h2>
      <ul>
<li><code>computed</code>属性是基于响应式数据进行计算，而<code>watch</code>属性用于监听响应式数据的变化。</li>
<li><code>computed</code>属性具有缓存机制，只有在依赖的响应式数据发生变化时才会重新计算，而<code>watch</code>属性则在每次数据变化时都会执行回调函数</li>
<li><code>methods</code>属性中定义的方法可以执行任意的逻辑操作，而<code>computed</code>属性和<code>watch</code>属性主要用于计算和监听数据的变化。</li>
<li><code>computed</code>属性可以像普通属性一样在模板中使用，而<code>watch</code>属性和<code>methods</code>属性需要在模板中通过方法调用或监听属性来使用。</li>
</ul>

        <h2 id="vue-路由传参及接收参数"   >
          <a href="#vue-路由传参及接收参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#vue-路由传参及接收参数" class="headerlink" title="vue 路由传参及接收参数"></a>vue 路由传参及接收参数</h2>
      <p>路由传参：params 传参、query 传参和 url 字符串拼接(编程式导航)<br>接收的参数：query params 字符串拼接</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://example.com">孙旭昌</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://example.com/2023/10/17/MyIquestion/">http://example.com/2023/10/17/MyIquestion/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2023/10/16/my-first-blog/"><span class="paginator-prev__text">Hello, the world</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E3%80%81%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">
          js 数据类型 、以及存储位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">
          堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">3.</span> <span class="toc-text">
          阻止事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.</span> <span class="toc-text">
          阻止默认行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">5.</span> <span class="toc-text">
          事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">6.</span> <span class="toc-text">
          事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD"><span class="toc-number">7.</span> <span class="toc-text">
          事件传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-number">8.</span> <span class="toc-text">
          事件捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Link-%E5%92%8C-import-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">
          Link 和@import 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">10.</span> <span class="toc-text">
          闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">11.</span> <span class="toc-text">
          递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">11.0.1.</span> <span class="toc-text">
          递归的特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">
          防抖和节流 区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8E%8C%E6%8F%A1%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">12.0.1.</span> <span class="toc-text">
          为什么要掌握防抖和节流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2-%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">13.</span> <span class="toc-text">
          强制转换 隐式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">
          数组方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-%E5%92%8C-post-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text">
          get 和 post 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-call-bind-apply-%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">
          说一下 call,bind,apply 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">
          箭头函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">
          普通函数与箭头函数的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-%E6%8C%87%E5%90%91"><span class="toc-number">19.</span> <span class="toc-text">
          this 指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax-%E8%AF%B7%E6%B1%82%E6%97%B6%EF%BC%8C%E8%A7%A3%E6%9E%90-json-%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">
          ajax 请求时，解析 json 数据？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F-Ajax-%E4%BA%94%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">21.</span> <span class="toc-text">
          原生 Ajax 五个基本步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">
          深拷贝 浅拷贝 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">23.</span> <span class="toc-text">
          原型和原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">24.</span> <span class="toc-text">
          高阶函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">25.</span> <span class="toc-text">
          同源策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">26.</span> <span class="toc-text">
          面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS3-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">27.</span> <span class="toc-text">
          CSS3 新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML5-%E6%96%B0%E6%A0%87%E7%AD%BE"><span class="toc-number">28.</span> <span class="toc-text">
          HTML5 新标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#display-none-%E4%B8%8E-visibility-hidden-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">29.</span> <span class="toc-text">
          display:none 与 visibility:hidden 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise"><span class="toc-number">30.</span> <span class="toc-text">
          Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-%E6%96%B9%E6%B3%95"><span class="toc-number">31.</span> <span class="toc-text">
          Promise 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Promise-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">31.1.</span> <span class="toc-text">
          一、Promise 静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Promise-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">31.2.</span> <span class="toc-text">
          二、Promise 实例方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AF%AD%E6%B3%95%E7%B3%96-Async-Await"><span class="toc-number">31.3.</span> <span class="toc-text">
          三、语法糖 Async&#x2F;Await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8%EF%BC%8C%E4%BB%96%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">32.</span> <span class="toc-text">
          浏览器存储，他们的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">33.</span> <span class="toc-text">
          什么是回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">34.</span> <span class="toc-text">
          js 创建对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-%E4%B8%8E-const-%E5%92%8C-var-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">35.</span> <span class="toc-text">
          let 与 const 和 var 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-%E5%92%8C-BOM-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">36.</span> <span class="toc-text">
          DOM 和 BOM 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5-url-%E4%B9%8B%E5%90%8E%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B"><span class="toc-number">37.</span> <span class="toc-text">
          浏览器输入 url 之后做了哪些事</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%8F%98-this-%E6%8C%87%E5%90%91%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">38.</span> <span class="toc-text">
          改变 this 指向的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">39.</span> <span class="toc-text">
          new 操作符的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">40.</span> <span class="toc-text">
          三次握手和四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%89%E7%9A%84%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">40.1.</span> <span class="toc-text">
          三次握手（建立连接）的过程如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%EF%BC%89%E7%9A%84%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">40.2.</span> <span class="toc-text">
          四次挥手（关闭连接）的过程如下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5-%E7%9A%84-API"><span class="toc-number">41.</span> <span class="toc-text">
          H5 的 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sass-%E8%AF%AD%E6%B3%95"><span class="toc-number">42.</span> <span class="toc-text">
          sass 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">43.</span> <span class="toc-text">
          作用域和作用域链之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">44.</span> <span class="toc-text">
          Math 常用的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">45.</span> <span class="toc-text">
          ES6 新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">46.</span> <span class="toc-text">
          前端性能优化的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">47.</span> <span class="toc-text">
          JavaScript 垃圾回收原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">48.</span> <span class="toc-text">
          判断一个对象是否为空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-number">49.</span> <span class="toc-text">
          HTML 渲染过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-number">50.</span> <span class="toc-text">
          axios</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VUE"><span class="toc-number"></span> <span class="toc-text">
          VUE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-vuex%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">
          什么是 vuex？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-js-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">
          vue.js 的两个核心是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">
          vuex 的工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-computed-%E5%92%8C-watch%E3%80%81methods-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">
          Vue 中的 computed 和 watch、methods 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E5%8F%8A%E6%8E%A5%E6%94%B6%E5%8F%82%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">
          vue 路由传参及接收参数</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://img2.woyaogexing.com/2023/10/05/397d244beeeb0a7d1fed53d1592272f3.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">轻舟已过万重山</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/sssxxxccc/sssxxxccc.github.io" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://plus.google.com/" target="_blank" rel="noopener" data-popover="Google" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-google"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a><a class="sidebar-ov-social-item" href="https://youtube.com/" target="_blank" rel="noopener" data-popover="Youtube" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-youtube"></i></span></a><a class="sidebar-ov-social-item" href="2803250335" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">3</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">0</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>孙旭昌</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div><div>人性一个最特别的弱点就是：在意别人如何看待自己。</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>